name: Build and Deploy TEE

on:
    workflow_call:

# Useful commands:
#
# List all images that support Intel TDX:
#   gcloud alpha compute images list \
#     --project=tdx-guest-images \
#     --filter="guestOsFeatures[].type:(TDX_CAPABLE)"
#
# List GuestOS features for a specific image:
#   gcloud compute images describe-from-family ubuntu-2204-lts --project ubuntu-os-cloud
#
# Requires the following additional Google Cloud APIs:
#   - Compute Engine API
#   - Confidential Computing API
#   - Cloud Build API

env:
    GOOGLE_CLOUD_PROJECT: tee-3fed2f
    GOOGLE_WORKLOAD_IDENTITY_PROVIDER: projects/1035454626678/locations/global/workloadIdentityPools/github/providers/pluto-tee-web-prover
    CLOUD_VM_BUCKET: tee-3fed2f-images-2c95ac # write only
    PLUTO_VM_BUCKET: tee-3fed2f-images-a3db73
    BASE_VM_IMAGE_NAME: ubuntu-2204-lts
    BASE_VM_IMAGE_PROJECT: ubuntu-os-cloud
    CLOUDFLARE_DNS_ZONE_ID: 1d20e7dd6bf74aa550038d25bd4ac8b8
    CLOUDFLARE_DOMAIN: pluto.dev

jobs:
    build:
        runs-on: ubuntu-latest
        permissions:
            contents: "read"
            id-token: "write"

        steps:
            - uses: actions/checkout@v4

            - name: Get git short hash
              id: git-hash
              run: echo "SHORT_HASH=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

            - uses: "google-github-actions/auth@v2"
              if: ${{ !env.ACT }}
              with:
                  project_id: ${{ env.GOOGLE_CLOUD_PROJECT }}
                  workload_identity_provider: ${{ env.GOOGLE_WORKLOAD_IDENTITY_PROVIDER }}

            - uses: "google-github-actions/auth@v2"
              if: ${{ env.ACT }}
              with:
                  project_id: ${{ env.GOOGLE_CLOUD_PROJECT }}
                  credentials_json: ${{ secrets.GOOGLE_CLOUD_SERVICE_ACCOUNT_CREDENTIALS_JSON }}

            - name: "Set up Cloud SDK"
              uses: "google-github-actions/setup-gcloud@v2"
              with:
                  version: ">= 506.0.0"

            - name: Get latest VM image
              id: vm-image
              run: |
                  # Get both image name and features in a single command
                  IMAGE_INFO=$(gcloud compute images describe-from-family ${{ env.BASE_VM_IMAGE_NAME }} \
                    --project ${{ env.BASE_VM_IMAGE_PROJECT }} \
                    --format="json")

                  # Extract and set outputs using jq
                  NAME=$(echo "$IMAGE_INFO" | jq -r '.name')
                  FEATURES=$(echo "$IMAGE_INFO" | jq -r '.guestOsFeatures[].type' | tr '\n' ',')

                  echo "NAME=${NAME}" >> $GITHUB_OUTPUT
                  echo "FEATURES=${FEATURES}" >> $GITHUB_OUTPUT

                  # Check if the VM image supports Intel TDX
                  if [[ ! "$FEATURES" == *"TDX_CAPABLE"* ]]; then
                    echo "ERROR: The VM image ${{ env.BASE_VM_IMAGE_NAME }} does not have feature TDX_CAPABLE enabled."
                    echo "Features: $FEATURES"
                  fi

            - name: Ensure bucket retention policy is locked
              run: |
                  BUCKET=$(gcloud storage buckets describe gs://${{ env.CLOUD_VM_BUCKET }} --format="json")

                  # Check if object retention policy is enabled and locked
                  if [[ $(echo $BUCKET | jq -r '.retention_policy.isLocked') != "true" ]]; then
                    echo "ERROR: Bucket retention policy is not locked for ${{ env.CLOUD_VM_BUCKET }}."
                    exit 1
                  fi

                  # Also check the retention period to ensure it's suitable (e.g. minimum 30 days)
                  RETENTION_PERIOD=$(echo $BUCKET | jq -r '.retention_policy.retentionPeriod')
                  if [[ "$RETENTION_PERIOD" -lt 2592000 ]]; then
                    echo "ERROR: Bucket retention policy is less than 30 days ${{ env.CLOUD_VM_BUCKET }}."
                    exit 1
                  fi

            - name: Export existing VM image to a Google Cloud Storage Bucket
              run: |
                  # Check if we already have this image exported
                  if gsutil -q stat gs://${{ env.CLOUD_VM_BUCKET }}/${{ steps.vm-image.outputs.NAME }}.raw; then
                    exit 0
                  fi

                  # docs: https://cloud.google.com/compute/docs/import/requirements-export-import-images
                  gcloud compute images export \
                    --destination-uri gs://${{ env.CLOUD_VM_BUCKET }}/${{ steps.vm-image.outputs.NAME }}.raw \
                    --image-family ${{ env.BASE_VM_IMAGE_NAME }} \
                    --image-project ${{ env.BASE_VM_IMAGE_PROJECT }} \
                    --project ${{ env.GOOGLE_CLOUD_PROJECT }}

            - name: Download the original VM image
              run: |
                  gsutil cp gs://${{ env.CLOUD_VM_BUCKET }}/${{ steps.vm-image.outputs.NAME }}.raw disk.raw.tar.gz
                  echo "Decompressing disk.raw..."
                  tar -xvf disk.raw.tar.gz
                  rm disk.raw.tar.gz
                  if [ ! -f disk.raw ]; then
                    echo "ERROR: disk.raw does not exist!"
                    exit 1
                  fi

            - name: Add files to the VM image
              run: |
                  sudo apt-get update
                  sudo apt-get install -y --no-install-recommends fdisk

                  # Mount the image
                  OFFSET=$(sudo fdisk -l disk.raw | grep "Linux filesystem" | head -n 1 | awk '{print $2 * 512}')
                  mkdir mnt
                  sudo mount -o loop,offset=$OFFSET disk.raw mnt

                  # Add files to the image
                  # TODO
                  sudo cp README.md mnt/

                  sudo sync
                  sudo umount mnt

            - name: Upload the customized VM image to the Google Cloud Storage Bucket
              run: |
                  echo "Compressing disk.raw..."
                  tar -czvf disk.raw.tar.gz disk.raw
                  gsutil cp disk.raw.tar.gz gs://${{ env.PLUTO_VM_BUCKET }}/pluto-${{ env.BASE_VM_IMAGE_NAME }}-${{ steps.git-hash.outputs.SHORT_HASH }}.raw.tar.gz

            - name: Delete any existing Google Cloud Image
              run: |
                  gcloud compute images delete pluto-${{ env.BASE_VM_IMAGE_NAME }}-${{ steps.git-hash.outputs.SHORT_HASH }} \
                    --project ${{ env.GOOGLE_CLOUD_PROJECT }} \
                    --quiet || true

            - name: Create a new Google Cloud Image from the customized VM image
              run: |
                  gcloud compute images create pluto-${{ env.BASE_VM_IMAGE_NAME }}-${{ steps.git-hash.outputs.SHORT_HASH }} \
                    --source-uri gs://${{ env.PLUTO_VM_BUCKET }}/pluto-${{ env.BASE_VM_IMAGE_NAME }}-${{ steps.git-hash.outputs.SHORT_HASH }}.raw.tar.gz \
                    --guest-os-features="${{ steps.vm-image.outputs.FEATURES }}" \
                    --project ${{ env.GOOGLE_CLOUD_PROJECT }}

            - name: Delete any existing TEE instance
              run: |
                  gcloud compute instances delete tee-instance-${{ steps.git-hash.outputs.SHORT_HASH }} \
                    --zone us-central1-a \
                    --project ${{ env.GOOGLE_CLOUD_PROJECT }} \
                    --quiet || true

            - name: Create new TEE instance
              id: instance
              run: |
                  INSTANCE=`gcloud compute instances create tee-instance-${{ steps.git-hash.outputs.SHORT_HASH }} \
                    --machine-type c3-standard-4 \
                    --zone us-central1-a \
                    --network-interface=network-tier=PREMIUM,stack-type=IPV4_ONLY,subnet=default \
                    --metadata="git-hash=${{ github.sha }}" \
                    --scopes=https://www.googleapis.com/auth/cloud-platform \
                    --tags=tee \
                    --confidential-compute-type=TDX \
                    --shielded-secure-boot \
                    --maintenance-policy=TERMINATE \
                    --image pluto-${{ env.BASE_VM_IMAGE_NAME }}-${{ steps.git-hash.outputs.SHORT_HASH }} \
                    --project ${{ env.GOOGLE_CLOUD_PROJECT }} \
                    --format=json`

                  echo $INSTANCE
                  EXTERNAL_IP=$(echo $INSTANCE | jq -r '.[0].networkInterfaces[0].accessConfigs[0].natIP')
                  echo "::notice ::TEE instance external IP: ${EXTERNAL_IP}"
                  echo "EXTERNAL_IP=${EXTERNAL_IP}" >> $GITHUB_OUTPUT

            - name: Create Cloudflare DNS record
              run: |
                  RESPONSE=`curl -s --request POST \
                    --url https://api.cloudflare.com/client/v4/zones/${{ env.CLOUDFLARE_DNS_ZONE_ID }}/dns_records \
                    --header 'Content-Type: application/json' \
                    --header "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
                    --data "{ \
                      \"comment\": \"TEE ${{ steps.git-hash.outputs.SHORT_HASH }}\", \
                      \"name\": \"${{ steps.git-hash.outputs.SHORT_HASH }}.tee\", \
                      \"proxied\": false, \
                      \"settings\": {}, \
                      \"tags\": [], \
                      \"ttl\": 3600, \
                      \"content\": \"${{ steps.instance.outputs.EXTERNAL_IP }}\", \
                      \"type\": \"A\" \
                    }"`

                  echo $RESPONSE

                  # If record already exists, don't treat it as an error
                  if [ "$(echo $RESPONSE | jq -r .success)" == "false" ] && [ "$(echo $RESPONSE | jq -r '.errors[0].code')" == "81058" ]; then
                    echo "DNS record already exists. Continuing."
                  elif [ "$(echo $RESPONSE | jq -r .success)" != "true" ]; then
                    echo "Error: Cloudflare API call failed."
                    exit 1
                  fi

                  echo "::notice ::TEE URL:: ${{ steps.git-hash.outputs.SHORT_HASH }}.tee.${{ env.CLOUDFLARE_DOMAIN }}"
